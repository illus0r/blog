Женя Арутюнов предложил написать про устройство нашего паркового проекта Флоттери:

> Сколько там переменных, как они связаны, как влияют на форму. Что такое грамматика, какая она. Как из текста получается набор переменных.
> Как устроены все интеграции, как был устроен процесс совместной разработки.

Флоттери — это скорее искусство, чем сайт. Да, искусство бывает и на сайтах. Например, ХХХХХХ кодит интерактивные сайты публикует, а потом продаёт вместе с доменными именами.

Оооо, отвечаю.


Грамматику засунули в эксельку, чтобы работать вместе.
Чтобы её было быстрее вставлять в код, написал регулярное выражение для [вима](https://en.wikipedia.org/wiki/Vim_(text_editor)):
```
%s:\(<.\{-\}>\)\s*\(.*\)\s*$:\1\:\r- \2: | %s:\d\+_\d\+:<&>:g | %s:\s*$:: | %s:\s\+: :g
↑                                          ↑                    ↑           ↑         
1                                          2                    3           4
```
1. Разбивает каждое правило грамматики на две строки. В первой нетерминальный токен, во второй — во что он может превратиться.
2. Выбирает значения похожие на `16_16` и заворачивает их в треугольные скобки `<16_16>`.
3. Удаляет пробельные символы в концах строк.
4. Заменяет подряд идущие пробельные символы одним пробелом.

Каждый раз, когда Максим менял грамматику, я копировал ячейки из гуглдока в буфер обмена, вставлял в вим, выполнял эту комманду. И получал почти правильную грамматику, разве что стартовый символ ещё надо было разобрать на несколько строк-правил.

Ещё часть грамматики генерируется скриптом автоматически.

Для грамматики используем библиотеку [RiTa](https://rednoise.org/rita/reference/index.php).

Грамматика выбирает один из вариантов с одинаковой вероятностью.

Чтобы разрандомить, используем строку. Библиотека RiTa может сделать рандомность предсказуемой:

```
	RiTa.randomSeed(pseudoRandom);
```

На вход `randomSeed` принимает число, а на входе строка. Чтобы из неё сделать число, нашёл какую-то функцию на стековерфлоу, работает отлично:

```
function hashCode(str) {
	return str.split('').reduce((prevHash, currVal) =>
	  (((prevHash << 5) - prevHash) + currVal.charCodeAt(0))|0, 0)
  }
```
https://stackoverflow.com/a/34842797
{: .caption}

Вот сокращённый пример грамматики:
```
	<start>:
	- <type1>
	- <type2>
	- <type3>
	- <iceberg>
	<type1>:
	- <0_8> <8_8> <8_8> <8_32> <water> <32_32> <32_8> <8_0>
	<type2>:
	- <0_8> <8_8> <8_8> <8_64> <water> <64_64> <64_8> <8_0>
	<type3>:
	- <0_8> <8_8> <8_8> <8_128> <water> <128_128> <128_8> <8_0>
	<iceberg>:
	- <dragonfly> <0_32> <water> <32_128> <128_8> <8_0>
	<water>:
	- <0_0>
```
Разберём, что тут происходит.

`<start>` — это начальный токен. В начале есть только он, потом он превращается в другие токены в соответствии с правилами грамматики. Например, правило
```
	<start>:
	- <type1>
	- <type2>
	- <type3>
	- <iceberg>
```
означает, что `<start>` может превратиться в `<type1>`, `<type2>`, `<type3>` или в `<iceberg>`. Вероятность каждого варианта одинакова.

Допустим, мы получили токен `<type1>`. Посмотрим, во что может превратиться он:
```
	<type1>:
	- <0_8> <8_8> <8_8> <8_32> <water> <32_32> <32_8> <8_0>
```

Тут только один вариант. Зато какой! Из токена неминуемо получается целая цепочка других токенов. Причём `<water>` в свою очередь неминуемо превратится в `<0_0>`. Потому что такое правило в грамматике тоже есть.

И вот мы получили цепочку из каких-то циферок, которые ни во что превратиться не могут. Фокус в том, что могут. Потому что часть правил грамматики 



- Стрекоза
- Сколько там переменных, как они связаны, как влияют на форму. 
- Что такое грамматика, какая она. Как из текста получается набор переменных.
- Как устроены все интеграции, как был устроен процесс совместной разработки.
